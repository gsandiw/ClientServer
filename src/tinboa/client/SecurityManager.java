package tinboa.client;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.net.URL;
import java.security.Key;
import java.security.MessageDigest;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.util.LinkedList;
import java.util.List;
import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.CipherInputStream;
import javax.crypto.KeyGenerator;
import javax.crypto.SealedObject;
import javax.crypto.spec.IvParameterSpec;
import tinboa.core.FileMessage;
import tinboa.core.Message;
import tinboa.core.HexString;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

/**
 *  @author Yann Le Gall
 *  ylegall@gmail.com
 *  Feb 16, 2010 6:44:43 PM
 */
public final class SecurityManager
{

    private SecureRandom random;
    private GroupServerRecord groupServerRecrod;
    private FileServerRecord fileServerRecord;
    private IvParameterSpec groupIV, fileIV, encrFileIV;
    private Key groupAESKey, fileAESKey, backUpKey;
    private Cipher AEScipher, RSAcipher, FileCipher;
    private List<FileServerRecord> fileServerList;
    private static final SecurityManager instance = new SecurityManager();

    public static final SecurityManager getInstance() {
        return instance;
    }

    private SecurityManager() {

        Security.addProvider(new BouncyCastleProvider());
        fileServerList = new LinkedList<FileServerRecord>();

        try {

            // try to load a trusted host public key:
            groupServerRecrod = loadServerKey();
            loadFileServerKeys();
            random = SecureRandom.getInstance("SHA1PRNG");
            AEScipher = Cipher.getInstance("AES/CBC/PKCS5Padding", "BC");
            RSAcipher = Cipher.getInstance("RSA/NONE/PKCS1Padding", "BC");
            FileCipher = Cipher.getInstance("AES/CBC/PKCS5Padding", "BC");

            byte[] IV = new byte[16];
            for(int i = 0; i < 16; i++)
                IV[i] = (byte)(i * 3);
            encrFileIV = new IvParameterSpec(IV);

        } catch (Exception e) {
            System.err.println(e);
        }
    }

    public byte[] getRandom(int size) {
        return random.generateSeed(size);
    }

    final PublicKey getGroupServerKey() {
        return groupServerRecrod.getKey();
    }

    final PublicKey getFileServerKey() {
        return fileServerRecord.getKey();
    }

    /**
     * Backs up the current session key and makes a new one
     */
    public final void backUpKey(){
        backUpKey = groupAESKey;
    }

    /**
     * Sets the file server's public RSA key.
     * TODO: rename this to addKnownFileServer() or something
     * TODO: later we might need to store more information to
     * know which key to use.
     * @param key
     */
    final void addFileServerKey(String host, PublicKey key) {
        FileServerRecord fileRecord = new FileServerRecord(host, key);
        if (!fileServerList.contains(fileRecord)) {
            fileServerList.add(fileRecord);
        }
        fileServerRecord = fileRecord;
    }

    /**
     * Sets the group server's public RSA key.
     * @param key
     */
    public final void setGroupKey(String hostname, PublicKey key) {
        groupServerRecrod = new GroupServerRecord(hostname, key);
    }

    /**
     * Generates a new AESkey
     * @param fromServer the random bytes generated by the server.
     * @param fromClient the random byte that the client generated.
     */
    public final void setGroupSessionKey(byte[] fromServer, byte[] fromClient) {
        try {

            // copy the random bytes into a 128 byte seed:
            // and initialize the random generator:
            
//            byte[] seed = new byte[64];
//            for(int i=0; i<seed.length; i++) {
//                seed[i] = (byte)(fromServer[i] ^ fromClient[i]);
//            }

            byte[] seed = new byte[64];
            System.arraycopy(fromServer, 0, seed, 0, fromServer.length);
            System.arraycopy(fromClient, 0, seed, fromServer.length, fromClient.length);

            random.setSeed(seed);
            
            // generate a 128-bit AES key:
            KeyGenerator keyGen = KeyGenerator.getInstance("AES", "BC");
            keyGen.init(128, random);
            groupAESKey = keyGen.generateKey();
            
            // generate the IV:
            byte[] IV = new byte[16];
            random.nextBytes(IV);
            groupIV = new IvParameterSpec(IV);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Encrypts data using the public RSA
     * key of the groupServer of the fileServer.
     * @param forGroup true if the encryption will
     * use the GroupServer's key, false if it should
     * use the FileServer's key.
     * @param bytes input data, can't be larger than RSAcipher.getBlockSize().
     * @return the encrypted bytes, or null on error.
     */
    public final byte[] encrypSessionKey(byte[] bytes, boolean forGroup) {
        try {
            if(forGroup) {
                RSAcipher.init(Cipher.ENCRYPT_MODE, groupServerRecrod.getKey());
            } else {
                RSAcipher.init(Cipher.ENCRYPT_MODE, fileServerRecord.getKey());
            }
            return RSAcipher.doFinal(bytes);
        } catch (Exception e) {
            //System.err.println(e.getMessage());
            e.printStackTrace();
            return bytes;
        }
    }

    /**
     * Generates a new AESkey
     * @param fromServer the random bytes generated by the server.
     * @param fromClient the random byte that the client generated.
     */
    final void setFileSessionKey(byte[] fromServer, byte[] fromClient) {
        try {

            // copy the random bytes into a 128 byte seed:
            // and initialize the random generator:
            
//            byte[] seed = new byte[128];
//            for(int i=0; i < seed.length; i++) {
//                seed[i] = (byte)(fromServer[i] ^ fromClient[i]);
//            }

            byte[] seed = new byte[64];
            System.arraycopy(fromServer, 0, seed, 0, fromServer.length);
            System.arraycopy(fromClient, 0, seed, fromServer.length, fromClient.length);

            SecureRandom rand = SecureRandom.getInstance("SHA1PRNG");
            rand.setSeed(seed);

            // generate a 128-bit AES key:
            KeyGenerator keyGen = KeyGenerator.getInstance("AES", "BC");
            keyGen.init(128, rand);
            fileAESKey = keyGen.generateKey();

            // generate the IV:
            byte[] IV = new byte[16];
            rand.nextBytes(IV);
            fileIV = new IvParameterSpec(IV);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * downloads a file from the FileServer.
     * @param destFile The name of the destination file.
     * @param input The ObjectInputStream of the client's socket.
     * @param in The InputStream of the client's socket.
     * @return true if the file was successfully downloaded, false otherwise.
     */
    final boolean downloadFile(String destFile, ObjectInputStream input, InputStream in, byte[] key) {
        try {

            FileOutputStream fout = new FileOutputStream(destFile + ".tmp");
            BufferedOutputStream bout = new BufferedOutputStream(fout);

            // get the length of the file:
            long length = input.readLong();

            // initialized the cipher and cipher stream:
            AEScipher.init(Cipher.DECRYPT_MODE, fileAESKey, fileIV);

            int len;
            byte[] buffer = new byte[128];

            while (length > 0) {
                len = input.read(buffer);
                if (len < 0) {
                    break;
                }
                //bout.write(buffer, 0, len);
                if (length < buffer.length) {
                    bout.write(AEScipher.doFinal(buffer, 0, len));
                } else {
                    bout.write(AEScipher.update(buffer, 0, len));
                }

                length -= len;
            }

            bout.flush();
            bout.close();

            System.out.println("done.");
            getFile(destFile + ".tmp", destFile, key, length);
            File f = new File(destFile + ".tmp");
            f.delete();
            return true;

        } catch (Exception e) {
            //System.err.println(e);
            e.printStackTrace();
            return false;
        }
    }

//    /**
//     * downloads a file from the FileServer.
//     * @param destFile The name of the destination file.
//     * @param input The ObjectInputStream of the client's socket.
//     * @param in The InputStream of the client's socket.
//     * @return true if the file was successfully downloaded, false otherwise.
//     */
//    final boolean downloadFile(String destFile, ObjectInputStream input, InputStream in) {
//
//         FileOutputStream fout;
//         BufferedOutputStream bout;
//
//        try {
//
//            fout = new FileOutputStream(destFile);
//            bout = new BufferedOutputStream(fout);
//
//            // get the remaining of the file:
//            long remaining = input.readLong();
//
//            // initialized the cipher and cipher stream:
//            AEScipher.init(Cipher.DECRYPT_MODE, AESKey, iv);
//            CipherInputStream cin = new CipherInputStream(in, AEScipher);
//
//            int len;
//            byte[] buffer = new byte[64];
//            while (remaining > 0) {
//
//                len = cin.read(buffer);
//                if(len < 0) break;
//
//                if(remaining > buffer.length) {
//                    bout.write(buffer, 0, len);
//                } else {
//                    //bout.write(AEScipher.doFinal(), 0, (int)remaining);
//                    bout.write(buffer, 0, (int)remaining);
//                    //bout.write(buffer, 0, len);
//                    break;
//                }
//                remaining -= len;
//            }
//
//            bout.flush();
//            bout.close();
//
//            System.out.println("done.");
//            return true;
//
//        } catch (Exception e) {
//            System.err.println(e);
//            e.printStackTrace();
//            return false;
//        }
//    }
    /**
     * uploads a file to the FileServer.
     * @param file The file to upload.
     * @param output The ObjectOutputStream of the client's socket.
     * @return true if the file was successfully uploaded, false otherwise.
     */
    final boolean uploadFile(String source, ObjectOutputStream output, byte[] key) {//(File file, ObjectOutputStream output, byte[] key) {
        try {
            File file = getFile(source, source + ".tmp", key, -1);
            // getFile(source, dest, key, for encrypt)

            // upload file to socket from destination file:
            FileInputStream fin = new FileInputStream(file);
            BufferedInputStream bin = new BufferedInputStream(fin);
            AEScipher.init(Cipher.ENCRYPT_MODE, fileAESKey, fileIV);
            CipherOutputStream out = new CipherOutputStream(output, AEScipher);

            System.out.print("upload started...");

            int len;
            byte[] buffer = new byte[128];
            while ((len = bin.read(buffer)) > 0) {
                out.write(buffer, 0, len);
                //System.err.println(new String(buffer));
            }

            // call do final manually to avoid
            // closing the socket's stream:
            output.write(AEScipher.doFinal());
            out.flush();
            bin.close();
            System.out.print("done.");

            file.delete();
            return true;

        } catch (Exception e) {
            //System.err.println(e);
            e.printStackTrace();
            return false;
        }
    }

    final File getFile(String source, String destination, byte[] key, long length) {
        try {
            FileInputStream fis = new FileInputStream(source);
            FileOutputStream fos = new FileOutputStream(destination);
            int i = 0;

            SecureRandom rand = SecureRandom.getInstance("SHA1PRNG");
            rand.setSeed(key);

            // generate a 128-bit AES key:
            KeyGenerator keyGen = KeyGenerator.getInstance("AES", "BC");
            keyGen.init(128, rand);
            Key fileKey = keyGen.generateKey();

            if(length == -1) {
                FileCipher.init(Cipher.ENCRYPT_MODE, fileKey, encrFileIV);
            } else {
                FileCipher.init(Cipher.DECRYPT_MODE, fileKey, encrFileIV);
            }

            CipherOutputStream cos = new CipherOutputStream(fos, FileCipher);
            
            while(true) {
                i = fis.read();
                if(i == -1)
                    break;
                cos.write(i);
            }

            cos.flush();
            cos.close();
            fis.close();
        } catch(Exception e) {
            e.printStackTrace();
        }

        return new File(destination);
            /*
            HexString hex = new HexString();
            //System.out.println("source=" + source + "\ndest=" + destination + "\nlength=" + length);

            String s = "This is a string";
            byte[] b = s.getBytes();
            s = hex.toHexString(b);
            System.out.println(s);
            b = s.getBytes();
            s = new String(b);
            b = s.getBytes();
            s = hex.toHexString(b);
            System.out.println(s);
            b = hex.toByteArray(s);
            s = new String(b);


            FileInputStream fis = new FileInputStream(source);
            //BufferedInputStream bin = new BufferedInputStream(fis);
            FileOutputStream fos = new FileOutputStream(destination);
            if(length != -1)
                length = bin.available();

            SecureRandom rand = SecureRandom.getInstance("SHA1PRNG");
            rand.setSeed(key);

            // generate a 128-bit AES key:
            KeyGenerator keyGen = KeyGenerator.getInstance("AES", "BC");
            keyGen.init(128, rand);
            Key fileKey = keyGen.generateKey();

            int len = 0;
            byte[] buffer = new byte[128];

            if(length == -1) {
                length = fis.available();
                FileCipher.init(Cipher.ENCRYPT_MODE, fileKey, groupIV);
                CipherInputStream cis = new CipherInputStream(bin, FileCipher);
                //String tmp = "";
                
                while ((len = cis.read(buffer)) > 0) {
                    //tmp = hex.toHexString(buffer);
                    fos.write(buffer, 0, len);
                    length -= len;
                }
                
                cis.close();
                fos.close();
            } else {
                FileCipher.init(Cipher.DECRYPT_MODE, fileKey, groupIV);
                BufferedOutputStream bout = new BufferedOutputStream(fos);
                //CipherOutputStream out = new CipherOutputStream(bout, FileCipher);
                String tmp = "";
                length = (long)fis.available();
                //System.out.println(source + " is " + length + " long");
                while (length > 0) {
                    len = bin.read(buffer);
                    if (len < 0) {
                        break;
                    }
                    //tmp = hex.toHexString(buffer);
                    //buffer = tmp.getBytes();
                    //bout.write(buffer, 0, len);
                    //System.out.println("buffer=" + new String(buffer));
                    if (length < buffer.length) {
                        bout.write(FileCipher.doFinal(buffer, 0, len));
                    } else {
                        bout.write(FileCipher.update(buffer, 0, len));
                    }

                    //buffer = new byte[128];

                    length -= len;
                }

                bout.flush();
                bout.close();
                fis.close();
            }
            
                //CipherOutputStream out = new CipherOutputStream(fos, AEScipher);

                //int len = 0;
                //byte[] buffer = new byte[128];
                while ((len = bin.read(buffer)) > 0) {
                    out.write(buffer, 0, len);
                //System.err.println(new String(buffer));
                }
             
                //out.flush();
                //out.close();
                //bin.close();
            //}
        } catch(Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
        return new File(destination);*/
    }

    /**
     * Encrypts a serializable using the secret AES key
     * and returns a sealed object.
     * @param <T> the type of the message (Message, FileMessage)
     * @param message the message to be encrypted.
     * @return a SealedObject to be passed to the server.
     */
    public final <T extends Serializable> SealedObject encryptMessage(T message) {
        try {
            if(message instanceof FileMessage) {
                AEScipher.init(Cipher.ENCRYPT_MODE, fileAESKey, fileIV);
            } else {
                AEScipher.init(Cipher.ENCRYPT_MODE, groupAESKey, groupIV);
            }
            return new SealedObject(message, AEScipher);
        } catch (Exception e) {
            System.err.println(e);
            return null;
        }
    }

    /**
     * Decrypts an incomming SealedObject into a message.
     * @param o The SealedObject to decrypt
     * @return A decrypted Message object
     */
    public final Message decryptMessage(SealedObject o) {
        try {
            AEScipher.init(Cipher.DECRYPT_MODE, groupAESKey, groupIV);
            return (Message) o.getObject(AEScipher);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Decrypts an incomming SealedObject into a FileMessage.
     * @param o The SealedObject to decrypt
     * @return A decrypted FileMessage object
     */
    public final FileMessage decryptFileMessage(SealedObject o) {
        try {
            AEScipher.init(Cipher.DECRYPT_MODE, fileAESKey, fileIV);
            return (FileMessage) o.getObject(AEScipher);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Utility function to run a SHA-1 digest.
     * @param input The input to be hashed.
     * @return the byte[] containing the
     * output of the hash.
     */
    public static final byte[] digest(byte[] input) {
        MessageDigest md;
        try {
            md = MessageDigest.getInstance("SHA-1", "BC");
            return md.digest(input);
        } catch (Exception ex) {
            return input;
        }
    }

//    /**
//     * Gets the encypted bytes of this
//     * client's AES key
//     * @return
//     */
//    final byte[] getEncryptedAESKey(PublicKey RSAKey) {
//        if (RSAKey != null) {
//            try {
//                RSAcipher.init(Cipher.WRAP_MODE, RSAKey);
//                return RSAcipher.wrap(groupAESKey);
//            } catch (Exception e) {
//                e.printStackTrace();
//            }
//        }
//        // if exception or null RSA key:
//        return null;
//    }

//    /**
//     * Gets the bytes of this
//     * client's IV
//     * @return
//     */
//    final byte[] getIV() {
//        return groupIV.getIV();
//    }

    /**
     * if this SecurityManager currently has the public
     * key of a trusted group server, then it is saved
     * to a resource file.
     */
    final void saveServerKey() {
        if (this.groupServerRecrod != null) {
            saveServerKey(this.groupServerRecrod);
        }
    }

    /**
     * Tests whether the given (GroupServer, Key) pair
     * is equal to the locally recorded one.
     * @param gsr The GroupServerRecord
     * @return true if the GroupServer name and public key
     * match the current one, otherwise, false if there is no known
     * GroupServerRecord exists, or if the GroupRecords do not match
     */
    final boolean isKnownGroupServer(GroupServerRecord gsr) {
        if (this.groupServerRecrod == null) {
            return false;
        }
        return this.groupServerRecrod.equals(gsr);
    }

    /**
     * Tests whether the given (FileServer, Key) pair
     * is equal to any of the locally recorded ones.
     * @param fsr The FileServerRecord
     * @return true if the GroupServer name and public key
     * match the current one, otherwise, false if there is no known
     * GroupServerRecord exists, or if the GroupRecords do not match
     */
    final boolean isKnownFileServer(FileServerRecord fsr) {
        if (this.fileServerList == null) {
            return false;
        } else {
            if (fileServerList.contains(fsr)) {
                fileServerRecord = fsr;
                return true;
            } else {
                return false;
            }
        }
    }

    // saves the group server's key to a file for future use
    private final void saveServerKey(GroupServerRecord groupServerRecord) {
        try {
            File f;
            URL url;

            // try to find the file if it exists, otherwise create it:
            url = SecurityManager.class.getResource("/tinboa/client/.keystore");
            if (url == null) {
                url = SecurityManager.class.getResource("/tinboa/client/");
                f = new File(url.getPath() + ".keystore");
            } else {
                f = new File(url.getFile());
            }

            FileOutputStream fout = new FileOutputStream(f);
            ObjectOutputStream oos = new ObjectOutputStream(fout);

            oos.writeObject(groupServerRecord);
            oos.flush();
            oos.close();
        } catch (Exception e) {
            System.err.println(e);
            e.printStackTrace();
        }
    }

    // saves the RSA keys of trusted file servers
    final void saveFileServerKey() {
        try {
            File f;
            URL url;

            // try to find the file if it exists, otherwise create it:
            url = SecurityManager.class.getResource("/tinboa/client/.fkeystore");
            if (url == null) {
                url = SecurityManager.class.getResource("/tinboa/client/");
                f = new File(url.getPath() + ".fkeystore");
            } else {
                f = new File(url.getFile());
            }

            // write the list of trusted servers to the file
            FileOutputStream fout = new FileOutputStream(f);
            ObjectOutputStream oos = new ObjectOutputStream(fout);
            oos.writeObject(fileServerList);
            oos.close();

        } catch (Exception e) {
            System.err.println(e);
            e.printStackTrace();
        }
    }

    /**
     * Retrieves the public RSA key of any trusted GroupServer
     * from a resource file.
     * @return a GroupServerRecord
     */
    private final GroupServerRecord loadServerKey() {
        GroupServerRecord g = null;
        try {

            // try to load server info from resource file:
            File f;
            URL url;

            url = SecurityManager.class.getResource("/tinboa/client/.keystore");
            // if the resournce doesn't exist:
            if (url == null) {
                url = SecurityManager.class.getResource("/tinboa/client/");
                f = new File(url.getPath() + ".keystore");
                f.createNewFile();
            } else {
                f = new File(url.getFile());
                FileInputStream fis = new FileInputStream(f);
                if (fis.available() > 0) {
                    ObjectInputStream ois = new ObjectInputStream(fis);
                    g = (GroupServerRecord) ois.readObject();
                    ois.close();
                }
                fis.close();
            }
        } catch (Exception e) {
            System.err.println(e);
            e.printStackTrace();
        }
        return g;
    }

    /**
     * Retrieves the public RSA key of any trusted GroupServer
     * from a resource file.
     * @return a GroupServerRecord
     */
    private final void loadFileServerKeys() {
        URL url = SecurityManager.class.getResource("/tinboa/client/");
        File file = new File(url.getPath() + ".fkeystore");
        if (!file.exists()) {
            fileServerList = new LinkedList<FileServerRecord>();
        } else {
            try {
                ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
                fileServerList = (LinkedList<FileServerRecord>) ois.readObject();
                ois.close();
            } catch (Exception e) {
                fileServerList = new LinkedList<FileServerRecord>();
                System.err.println(e);
            }
        }
    }
}

/**
 * This is a small class to store known server information.
 * It stores a server name (hostname or IP) along with
 * a public RSA key and the groups file key.
 * @author ylegall
 */
final class GroupServerRecord implements Serializable
{

    private String serverName;
    private PublicKey key;
    private Key groupFileKey;

    public GroupServerRecord(String serverName, PublicKey key) {
        this.serverName = serverName;
        this.key = key;
    }

    public GroupServerRecord(String serverName, PublicKey key, Key groupKey) {
        this.serverName = serverName;
        this.key = key;
        this.groupFileKey = groupKey;
    }

    public void setGroupKey(Key grpKey){
        this.groupFileKey = grpKey;
    }

    public Key getGroupKey(){
        return groupFileKey;
    }
    
    public PublicKey getKey() {
        return key;
    }

    public String getServerName() {
        return serverName;
    }

    @Override
    public boolean equals(Object obj) {

        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }

        final GroupServerRecord other = (GroupServerRecord) obj;
        if (key != other.key && (key == null || !key.equals(other.key))) {
            return false;
        }

        // compare
        if (key == null || other.key == null) {
            return false;
        }
        byte[] myKey = key.getEncoded();
        byte[] theirKey = other.key.getEncoded();
        for (int i = 0; i < myKey.length; i++) {
            if (myKey[i] != theirKey[i]) {
                return false;
            }
        }

        return true;
    }
}

final class FileServerRecord implements Serializable
{

    private PublicKey fServerKey;
    private String fileServerName;

    public FileServerRecord(String name, PublicKey key) {
        this.fileServerName = name;
        this.fServerKey = key;
    }

    public PublicKey getKey() {
        return fServerKey;
    }

    public String getServerName() {
        return fileServerName;
    }

    @Override
    public boolean equals(Object obj) {

        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }

        final FileServerRecord other = (FileServerRecord) obj;
        if (fServerKey != other.fServerKey && (fServerKey == null
                || !fServerKey.equals(other.fServerKey))) {
            return false;
        }

        // compare
        // Can we compare the hashes of the keys?

        // that might be a good idea. It would save some space.
        // your call.
        if (fServerKey == null || other.fServerKey == null) {
            return false;
        }
        byte[] myKey = fServerKey.getEncoded();
        byte[] theirKey = other.fServerKey.getEncoded();
        for (int i = 0; i < myKey.length; i++) {
            if (myKey[i] != theirKey[i]) {
                return false;
            }
        }

        return true;
    }
}
