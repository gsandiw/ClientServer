
package tinboa.fileserver;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.net.URL;
import java.security.Key;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.Signature;
import java.util.HashMap;
import java.util.Map;
import javax.crypto.Cipher;
import javax.crypto.SealedObject;
import tinboa.core.FileMessage;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.jce.provider.JCERSAPublicKey;
import tinboa.core.Token;
import tinboa.core.UserToken;

/**
 *
 * @author gep19
 * TODO: if we want to be legit,
 * we should rename this to FSecurityManager because
 * in java, class names are capitalized
 */
public class fSecurityManager
{
    private SecureRandom random;
    private KeyPair RSAKeyPair;
    private Signature signature;
    private Cipher RSAcipher;
    private Map<String, PublicKey> groupServerKeys;
    private static final fSecurityManager instance = new fSecurityManager();

    public static final fSecurityManager getInstance() {
        return instance;
    }

    private fSecurityManager() {

        Security.addProvider(new BouncyCastleProvider());
        groupServerKeys = new HashMap<String, PublicKey>();

        try {
            // try to load a trusted host public key:
            random = SecureRandom.getInstance("SHA1PRNG");
            signature = Signature.getInstance("RSA", "BC");
            RSAcipher = Cipher.getInstance("RSA/NONE/PKCS1Padding", "BC");

            // try to load a key pair
            loadRSAKeys();
            loadGroupServerkeys();

        } catch (Exception e) {
            System.err.println(e);
        }
    }

    /**
     * Gets the RSA public key belonging to
     * this GroupServer.
     * @return the PublicKey
     */
    final PublicKey getPublicKey() {
        return this.RSAKeyPair.getPublic();
    }

    /**
     * Unwraps an AESKey using the private RSA key
     * @param key
     * @return true if everything was ok, false on error.
     */
    final Key unwrapAESKey(byte[] key) throws Exception{
        RSAcipher.init(Cipher.UNWRAP_MODE, RSAKeyPair.getPrivate());
        return RSAcipher.unwrap(key, "AES", Cipher.SECRET_KEY);
    }

     /**
     * Encrypts a serializable using the secret AES key
     * and returns a sealed object.
     * @param <T> the type of the message (Message, FileMessage)
     * @param message the message to be encrypted.
     * @return a SealedObject to be passed to the server.
     */
    final <T extends Serializable> SealedObject encryptMessage(T message, Cipher AEScipher) {
        try {
            return new SealedObject(message, AEScipher);
        } catch (Exception e) {
            System.err.println(e);
            return null;
        }
    }

    /**
     * Decrypts an incomming SealedObject into a file-message.
     * @param o The SealedObject to decrypt
     * @return A decrypted Message object
     */
    final FileMessage decryptFileMessage(SealedObject o, Cipher AEScipher) {
        try {
            return (FileMessage) o.getObject(AEScipher);
        } catch (Exception e) {
            System.err.println(e);
            return null;
        }
    }

    /**
     * Decrypts the session key sent by
     * the client using the private RSA key
     * @param bytes
     * @return the decrypted bytes, or the original
     * bytes on error.
     */
    final byte[] decryptSessionKey(byte[] bytes) {
        try {
            RSAcipher.init(Cipher.DECRYPT_MODE, RSAKeyPair.getPrivate());
            return RSAcipher.doFinal(bytes);
        } catch (Exception e) {
            System.err.println(e.getMessage());
            return bytes;
        }
    }

    /**
     * Gets a number of random bytes
     * usin a strong crpto algorithm.
     * @return
     */
    public byte[] getRandom(int number) {
        return random.generateSeed(number);
    }

    /**
     * Verifies the signature on the specified token.
     * Checks that the token has not been modified and
     * that it was generated by the GroupServer.
     * @param t
     * @return true if the signature is valid, false otherwise.
     */
    final boolean verifyTokenSignature(UserToken t) {
        try {
            
            // get the issuer of this token
            Token token = (Token) t;
            String issuer = t.getIssuer();
            String fileServer = token.getFileServer();
            // see if the issuer is recognized
            // if not, try to re-load keys:
            if(!groupServerKeys.containsKey(issuer)) {
                loadGroupServerkeys();
            }

            PublicKey publicKey = groupServerKeys.get(issuer);

            // check if this issuer is on record:
            if(publicKey != null) {
                signature.initVerify(publicKey);
                signature.update(digest(token.getBytes()));
                return signature.verify(token.getSignature());
            } else {
                return false;
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * Utility function to run a SHA-1 digest.
     * @param input The input to be hashed.
     * @return the byte[] containing the
     * output of the hash.
     */
    public static final byte[] digest(byte[] input) {
        MessageDigest md;
        try {
            md = MessageDigest.getInstance("SHA-1", "BC");
            return md.digest(input);
        } catch (Exception ex) {
            return input;
        }
    }

    /**
     * Retrieves the public RSA key of this fileServer
     * from a resource file
     */
    private final void loadRSAKeys() {
        try {
            // try to load server info from resource file:
            File f;
            URL url;

            url = fSecurityManager.class.getResource("/tinboa/fileserver/.fkeystore");
            // if the resournce doesn't exist:
            if (url == null) {
                url = fSecurityManager.class.getResource("/tinboa/fileserver/");
                f = new File(url.getPath() + ".fkeystore");
                makeRSAKeys(f); //create or overwrite a file
            } else {
                f = new File(url.getFile());
                FileInputStream fis = new FileInputStream(f);
                if(fis.available() > 0) {
                    ObjectInputStream ois = new ObjectInputStream(fis);
                    RSAKeyPair = (KeyPair)ois.readObject();
                    ois.close();
                }
                fis.close();
            }
        } catch (Exception e) {
            System.err.println(e);
            e.printStackTrace();
        }
    }

    // this function generates new RSA keys whenever
    // no stored keys are detected. The new keys are
    // saved to a resource file.
    private final void makeRSAKeys(File keyFile) {

        try {
            // create the keys:
            KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA", "BC");
            generator.initialize(512, random);
            RSAKeyPair = generator.generateKeyPair();

            // save Keys to file
            FileOutputStream fos = new FileOutputStream(keyFile);
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(RSAKeyPair);
            oos.close();

        } catch (Exception e) {
            System.err.println(e);
            e.printStackTrace();
        }
    }

    // looks for all files ending in publicKey.ser
    // these files contain the public RSA keys of
    // trusted group servers
    final void loadGroupServerkeys() {
        try {
            // try to load server info from resource file:
            ObjectInputStream ois;
            URL url = fSecurityManager.class.getResource("/tinboa/fileserver/");
            File directory = new File(url.getFile() + "GroupServerKeys");

            // if there is no directory, make one
            if(!directory.exists() || !directory.isDirectory()) {
                directory.mkdir();
                System.out.println("warning: no group server public keys found.");
                return;
            } else {
                // get the directory and list all files/folders inside:
                // add each (hostName, Key) pair to a list of trusted hosts:
                for(String fileName : directory.list()) {
                    if(fileName.endsWith("publicKey.ser")) {
                        ois  = new ObjectInputStream(new FileInputStream(new File(directory.getPath()+ File.separator + fileName)));
                        fileName = fileName.substring(0, fileName.indexOf('_'));
                        groupServerKeys.put(fileName, (JCERSAPublicKey)ois.readObject());
                        ois.close();
                    }
                }
            }            
        } catch (Exception e) {
            System.err.println(e);
            e.printStackTrace();
        }
    }

}
